# Задача #1
# Дана отсортированная последовательность чисел
# длиной N и число K
# Необходимо найти количество пар чисел A, B, таких что B-A > K

# Решение #1 - O(N^2)
def slow(seq, k):
    count = 0
    for l in range(len(seq)):
        for r in range(l, len(seq)):
            if seq[r] - seq[l] > k:
                count += 1
    return count

# Решение #2 - O(N)
# Найдем наименьшее число и найдем для него первое подходящее
# большее. Все еще большие числа точно подходят. Возьмем в качестве
# меньшего числа следующее, а указатель первого подходящего
# большего будем двигать начиная с той позиции, где он онаходится
# сейчас
def countPairs(seq, k):
    count = 0
    r = 0

    for l in range(len(seq)):
        while r < len(seq) and seq[r] - seq[l] <= k:
            r += 1
        count += len(seq) - r

    return count

# test
seq = [1, 3, 7, 8, 10, 12, 13, 145, 156, 789, 1001, 1002, 1003]
k = 4
print('slow: ', slow(seq, k))
print('fast: ', countPairs(seq, k))



# Задача #2
# Игрок в футбол обладает одной числовой характеристикой -
# профессионализмом. Команда называется сплоченной, если
# профессионализм любого игрока не превосходит суммарный
# профессионализ любых двух других игроков из команды.
# Команда может состоять из любого количества игроков.
# Дана отсортированная последовательность чисел длиной N -
# профессионализм игроков.
# Необходимо найти максимальный суммарный профессионализм
# сплоченный команды.

# Решение
# Будем двигать правый указатель от самого сильного игрока влево
# и для каждого положения указателя R искать такое положение левого
# указателя L, при котором еще выполняется условие сплоченности
# команды (также при поиске крайне левого положения указателя L будем
# высчитывать профессионализм команды). Если такая пара указателей
# найдена, то сравниваем ее професионализм с найденным ранее
# и запоминаем максимальный из них
def maxFriendlyTeam(seq):
    ans = 0
    for r in range(len(seq) - 1, 1, -1):

        # чтобы получилось точно O(N)
        # тут нужно оптимизировать - левый указатель двигать не от r-2,
        # а от последнего найденного, но тогда надо по другому инициализировать
        # сумму команды и проверять, чтобы указатели не сошлись
        l = r - 2

        prof = seq[l + 1] + seq[r]
        while l >= 0 and seq[l] + seq[l + 1] >= seq[r]:
            prof += seq[l]
            l -= 1
        if l < r - 2 and prof > ans:
            ans = prof
    return ans

seq = [21, 23, 24, 25, 27, 28, 29, 30, 50, 51, 100]
print(maxFriendlyTeam(seq)) # 240



# Задача #3
# Даны две отсортированные последовательности чисел
# (длиной N и M соответственно)
# Необходимо слить их в одну отсортированную последовательность

# Решение
# Поставим два указателя на начало каждой из последовательностей.
# Выберем тот, которй указывает на меньшее число, запишем это
# число в результат и сдвинем указатель
def concatSeq(seq1, seq2):
    ans = []
    f = 0
    s = 0
    for i in range(len(seq1) + len(seq2)):
        if s >= len(seq2) or (f < len(seq1) and seq1[f] <= seq2[s]):
            ans.append(seq1[f])
            f += 1
        elif f >= len(seq1) or (s < len(seq2) and seq2[s] <= seq1[f]):
            ans.append(seq2[s])
            s += 1
    return ans

seq2 = [10, 20, 30, 70, 100]
seq1 = [1, 2, 3, 50, 80]
print(concatSeq(seq1, seq2))