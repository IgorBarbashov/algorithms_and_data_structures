# Задача #1
# Дана последовательность положительных чисел длиной N и число X
# Нужно найти два различных числа A и B из последовательности,
# таких что A + B = X или вернуть пару 0, 0,
# если такой пары нет

# Решение #1 - O(N^2)
# Переберем число A за O(N). Переберем число B за O(N).
# Если их сумма равна X, то вернем эту пару

def findtwonumbersumx(nums, x):
    for i in range(len(nums) - 1):
        for j in range(i + 1, len(nums)):
            if nums[i] != nums[j] and nums[i] + nums[j] == x:
                return nums[i], nums[j]
    return 0, 0

# Решение #2 - O(N)
# Будем хранить все уже обработанные числа в множестве.
# Если очередное число nownum, а (X - nuwmonw) есть
# в множестве, то мы нашли слагаемые

def findtwonumbersumx(nums, x):
    dct = set()
    for i in nums:
        if x - i in dct:
            return i, x - i
        dct.add(i)
    return 0, 0



# Задача #2
# Дан словарь из N слов, длина каждого не превосходит K
# В записи каждого из M слов текста (каждое длиной до K)
# может быть пропущена одна буква. Для каждого слова
# сказать, входит ли оно (возможно, с одной пропущенной
# буквой), в словарь

# Решение - O(N * K + M)
# на самом деле O(N * K^2 + M), т.к. новое слово создается за O(K)
# Выбросим из каждого слова словаря по одной букве всеми
# возможными способами за O(N * K) и положим получившиеся
# слова в множества
# Для каждого слова из текста просто проверим, есть ли оно
# в словаре за O(1)

def findword(dct, text):
    errdct = set(dct)
    for word in dct:
        for i in range(len(word)):
            errdct.add(word[:i] + word[i + 1:])
    ans = []
    for word in text:
        ans.append(word in errdct)
    return ans
