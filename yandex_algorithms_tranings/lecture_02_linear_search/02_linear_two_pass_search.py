# Задача #6
# Дана последовательность слов
# Вывести все самые короткие слова через пробел

# Решение
# На первом проходе перебираем все слова и ищем минимальную длину слова.
# На втором проходе опять перебираем все слова и если длина текущего слова
# равна минимальной, сохраняем его в ответе

def shortwords(words):
    minlen = len(words[0])
    for word in words:
        if len(word) < minlen:
            minlen = len(word)
    ans = []
    for word in words:
        if len(word) == minlen:
            ans.append(word)
    return ' '.join(ans)



# Задача #7
# Игра PitCraft происходит в двумерном мире, который состоит
# из блоков размером 1 на 1 метр. Остров игрока представляет
# собой набор столбцов различной высоты, состоящих из блоков
# камня и окруженный морем. Над островом прошел сильный 
# дождь, который заполнил водой все низины, а непоместившаяся
# в них вода стекла в море, не увеличив его уровень
# По ландшафту озера определите, сколько блоков воды осталось
# после дождя в низинах на острове

# Решение
# Сначала находим индекс максимальной вершины (если максимумов несколько,
# нам подойдет любой их них). Затем перебираем два отрезка - с левого края
# до максимума, и второй - с правого края до максимума.
# Для каждого отрезка:
# - запоминаем локальный максимум
# - если текущий элемент ниже локального максимума, то в нем скопится
#   (localMax - seq[i]) воды; прибавляем это значение к общему счетчику
#   воды и переходим к следующему элементу отрезка
# - если текущий элемент выше локального максимума, обновляем максимум,
#   общий счетчик воды не увеличиваем

def countWater(h):
    maxpos = 0
    for i in range(len(h)):
        if h[i] > h[maxpos]:
            maxpos = i
    ans = 0
    maxH = 0
    for i in range(maxpos):
        if h[i] > maxH:
            maxH = h[i]
        ans += maxH - h[i]
    maxH = 0
    for i in range(len(h) - 1, maxpos, -1):
        if h[i] > maxH:
            maxH = h[i]
        ans += maxH - h[i]
    return ans



# Задача #8
# Дана строка (возможно пустая), состоящая из букв A-Z:
# AAAAABBBBCCXYZDDDDDEEEEEEEFFAAAAAABBBBBBBBBBBBBBBBBBBBB
# Нужно написать функцию RLE, которая на выходе даст строку вида:
# A5B4C2XYZD5E7F2A6B21. И сгенерирует ошибку, если на вход
# пришла невалидная строка.
# Пояснения:
# - если символ встречается один раз, он остается без изменений
# - если символ повторяется более одного раза, к нему
#   добавляетя количество повторений

# Решение
# - проверяем на пустоту строки, если пустая - выводим пустую строку
# - берем первый символ
#   - если он валидный:
#     - устанавливаем значение переменной счетчика = 1
#     - устанавливаем значение переменной текущего символа = первому символу
#   - если он не валидный - выдаем ошибку

# - перебираем все символы строки начиная со второго
#   - если видим невалидный символ, выдаем ошибку
#   - если символ валидный
#     - если этот символ отличается от того что у нас в переменной,
#       сохраняем в результат накопленные данные (при кол-ве = 1
#       сохраняем только сам символ без счетчика), запоминаем
#       в переменную текущий символ и сбрасываем локальный счетчик = 1
#     - если символ такой же что и в переменной, увеличиваем счетчик
#     - переходим к следующему символу

def rle(s):
    def isValid(c):
        return c >= 'A' and c <= 'Z'

    def pack(s, c):
        return sym if count == 1 else sym + str(count)

    if len(s) == 0:
        return ''
    if not isValid(s[0]):
        return 'error'

    ans = []
    sym = s[0]
    count = 1
    for i in range(1, len(s)):
        if not isValid(s[i]):
            return 'error'
        if s[i] == sym:
            count += 1
        else:
            ans.append(pack(sym, count))
            sym = s[i]
            count = 1
    ans.append(pack(sym, count))

    return ''.join(ans)

print(rle('AAAAABBBBCCXYZDDDDDEEEEEEEFFAAAAAABBBBBBBBBBBBBBBBBBBBB'))
# ответ - A5B4C2XYZD5E7F2A6B21